#pragma ident "$Id: main.c,v 1.5 2013/07/19 18:14:19 dechavez Exp $"
#include "sbd.h"
#include "addoss.h"

#define IMEI_IDA   "300025010418970"
#define IMEI_CECIL "300025010416330"

static void help(char *myname)
{
static char *message = 
"usage: tstsbd destination [ command ] SBD_server\n"
"\n"
"where destination is either `ida' or `cecil'\n"
"\n"
"In the absence of any commands, the program will read up to 256 bytes from\n"
"stdin and send it in an SBD message to the server specified on the command\n"
"line. The SBD server for communication with the wave glider is sbd.pac.disa.mil.\n"
"\n"
"There are 3 pre-built commands that are generated by this program:\n"
"\n"
"os = request OBP status (payload ID 4)\n"
"gs = request Wave glider status (payload ID 2)\n"
"rd = request archived data (payload ID 8)\n"
"\n"
"Example 1) Send an OBP status request to CECIL\n"
"           tstsbd cecil os sbd.pac.disa.mil\n"
"\n"
"Example 2) Send an OSG status request to CECIL\n"
"           tstsbd cecil gs sbd.pac.disa.mil\n"
"\n"
"Example 3) Request 2 sectors of archived data from IDA\n"
"           tstsbd ida rd 0xstart_sector 0xend_sector sbd.pac.disa.mil\n"
"\n"
"Example 4) Send 256 bytes of your own creation to IDA glider\n"
"           tstsbd ida sbd.pac.disa.mil < my_256_byte_data_file\n"
"\n"
"           note: if input is less than 256 byte the rest is 0 padded.\n"
"                 and if more than 256 byte the rest is ignored.";

    fprintf(stderr, "%s\n", message);
    exit(1);
}

static void BuildMO(SBD_MO *mo)
{
static UINT8 payload[256] = {
    0x0A, 0x00, 0x00, 0xE9, 0x9F, 0x34, 0x50, 0x65, 0x04, 0x00, 0xFC, 0xFF, 0x7F, 0xFC, 0xFF, 0x7F,
    0xFC, 0xFF, 0x7F, 0xFC, 0xFF, 0x7F, 0xFC, 0xFF, 0x7F, 0xFC, 0xFF, 0x7F, 0xFC, 0xFF, 0x7F, 0xFC,
    0xFF, 0x7F, 0xFC, 0xFF, 0x7F, 0xFC, 0xFF, 0x7F, 0xFC, 0xFF, 0x7F, 0xFC, 0xFF, 0x7F, 0xFC, 0xFF,
    0x7F, 0xFC, 0xFF, 0x7F, 0xFC, 0xFF, 0x7F, 0xFC, 0xFF, 0x7F, 0xFC, 0xFF, 0x7F, 0xFC, 0xFF, 0x7F,
    0xFC, 0xFF, 0x7F, 0xFC, 0xFF, 0x7F, 0xFC, 0xFF, 0x7F, 0xFC, 0xFF, 0x7F, 0xFC, 0xFF, 0x7F, 0xFC,
    0xFF, 0x7F, 0xFC, 0xFF, 0x7F, 0xFC, 0xFF, 0x7F, 0xFC, 0xFF, 0x7F, 0xFC, 0xFF, 0x7F, 0xFC, 0xFF,
    0x7F, 0xFC, 0xFF, 0x7F, 0xFC, 0xFF, 0x7F, 0xFC, 0xFF, 0x7F, 0xFC, 0xFF, 0x7F, 0xFC, 0xFF, 0x7F,
    0xFC, 0xFF, 0x7F, 0xFC, 0xFF, 0x7F, 0xFC, 0xFF, 0x7F, 0xFC, 0xFF, 0x7F, 0xFC, 0xFF, 0x7F, 0xFC,
    0xFF, 0x7F, 0xFC, 0xFF, 0x7F, 0xFC, 0xFF, 0x7F, 0xFC, 0xFF, 0x7F, 0xFC, 0xFF, 0x7F, 0xFC, 0xFF,
    0x7F, 0xFC, 0xFF, 0x7F, 0xFC, 0xFF, 0x7F, 0xFC, 0xFF, 0x7F, 0xFC, 0xFF, 0x7F, 0xFC, 0xFF, 0x7F,
    0xFC, 0xFF, 0x7F, 0xFC, 0xFF, 0x7F, 0xFC, 0xFF, 0x7F, 0xFC, 0xFF, 0x7F, 0xFC, 0xFF, 0x7F, 0xFC,
    0xFF, 0x7F, 0xFC, 0xFF, 0x7F, 0xFC, 0xFF, 0x7F, 0xFC, 0xFF, 0x7F, 0xFC, 0xFF, 0x7F, 0xFC, 0xFF,
    0x7F, 0xFC, 0xFF, 0x7F, 0xFC, 0xFF, 0x7F, 0xFC, 0xFF, 0x7F, 0xFC, 0xFF, 0x7F, 0xFC, 0xFF, 0x7F,
    0xFC, 0xFF, 0x7F, 0xFC, 0xFF, 0x7F, 0xFC, 0xFF, 0x7F, 0xFC, 0xFF, 0x7F, 0xFC, 0xFF, 0x7F, 0xFC,
    0xFF, 0x7F, 0xFC, 0xFF, 0x7F, 0xFC, 0xFF, 0x7F, 0xFC, 0xFF, 0x7F, 0xFC, 0xFF, 0x7F, 0xFC, 0xFF,
    0x7F, 0xFC, 0xFF, 0x7F, 0xFC, 0xFF, 0x7F, 0xFC, 0xFF, 0x7F, 0xFC, 0xFF, 0x7F, 0xFC, 0xFF, 0x7F
};
    mo->header.cdr    = 123456789;
    sprintf(mo->header.imei, "300025010416330");
    mo->header.status = 0;
    mo->header.momsn  = 1;
    mo->header.mtmsn  = 2;
    mo->header.tstamp = time(NULL);
    mo->header.valid  = TRUE;

	memcpy(mo->payload.data, payload, 256);
	mo->payload.len = 256;
 //   sprintf(mo->payload.data, "MO test message\n");
 //   mo->payload.len = strlen(mo->payload.data);
    mo->payload.valid = TRUE;

    mo->location.lat = 32.8678;
    mo->location.lon = -117.2524;
    mo->location.cep = 12;
    mo->location.valid = TRUE;

    mo->confirm.status = TRUE;
    mo->confirm.valid = TRUE;
}

static void BuildMT(SBD_MT *mt, char *imei)
{
time_t now;

    now = time(NULL);
    utilPackUINT32(mt->header.myid, now);
    sprintf(mt->header.imei, imei);
    mt->header.flags = SBD_MT_FLAG_NONE;
    mt->header.valid = TRUE;
    sprintf(mt->payload.data, "MT test message\n");
    mt->payload.len = strlen(mt->payload.data);
    mt->payload.valid = TRUE;
}

static void BuildStatusRequest(SBD_MT *mt, char *imei, UINT16 code)
{
time_t now;

    now = time(NULL);
    utilPackUINT32(mt->header.myid, now);
    sprintf(mt->header.imei, imei);
    mt->header.flags = SBD_MT_FLAG_NONE;
    mt->header.valid = TRUE;
    memset(mt->payload.data, 0, ADDOSS_FRAME_LEN);
    utilKcapUINT16(mt->payload.data, code);
    mt->payload.len = ADDOSS_FRAME_LEN;
    mt->payload.valid = TRUE;
}

static void BuildArchiveRequest(SBD_MT *mt, char *imei, UINT32 start, UINT32 end)
{
UINT8 *ptr;
time_t now;

    now = time(NULL);
    utilPackUINT32(mt->header.myid, now);
    sprintf(mt->header.imei, imei);
    mt->header.flags = SBD_MT_FLAG_NONE;
    mt->header.valid = TRUE;
    memset(mt->payload.data, 0, ADDOSS_FRAME_LEN);
    ptr = mt->payload.data;
    ptr += utilKcapUINT16(ptr, ADDOSS_ID_REQ_SENSOR_DATA);
    ptr += 2; /* skip over padding */
    ptr += utilKcapUINT32(ptr, start);
    ptr += utilKcapUINT32(ptr, end);
    mt->payload.len = ADDOSS_FRAME_LEN;
    mt->payload.valid = TRUE;
}

static void BuildUserMessage(SBD_MT *mt, char *imei, FILE *fp)
{
int nread;
time_t now;

    now = time(NULL);
    utilPackUINT32(mt->header.myid, now);
    sprintf(mt->header.imei, imei);
    mt->header.flags = SBD_MT_FLAG_NONE;
    mt->header.valid = TRUE;
    nread = fread(mt->payload.data, 1, ADDOSS_FRAME_LEN, fp);
    if (nread < 0) {
        perror("error reading user data");
        exit(1);
    } else if (nread < ADDOSS_FRAME_LEN) {
        memset(mt->payload.data + nread, 0, ADDOSS_FRAME_LEN - nread);
    }
    mt->payload.len = ADDOSS_FRAME_LEN;
    mt->payload.valid = TRUE;
}

int main(int argc, char **argv)
{
int i, retval;
static char *server = NULL;
static int port = SBD_DEFAULT_PORT;
SBD *sbd;
SBD_MESSAGE message;
UINT32 start, end;
char *imei;
static char *imei_ida   = IMEI_IDA;
static char *imei_cecil = IMEI_CECIL;

    sbdClearMessage(&message);

    if (argc < 3) help(argv[0]);

    if (strcasecmp(argv[1], "ida") == 0) {
        imei = imei_ida;
    } else if (strcasecmp(argv[1], "cecil") == 0) {
        imei = imei_cecil;
    } else {
        fprintf(stderr, "`ida' and `cecil' are the only supported waveglider destinations\n");
        help(argv[0]);
    }

    if (argc == 3) {
        BuildUserMessage(&message.mt, imei, stdin);
        server = argv[1];
    } else if (argc == 4) {
        if (strcasecmp(argv[2], "mo") == 0) {
            BuildMO(&message.mo);
        } else if (strcasecmp(argv[2], "mt") == 0) {
            BuildMT(&message.mt, imei);
        } else if (strcasecmp(argv[2], "gs") == 0) {
            BuildStatusRequest(&message.mt, imei, ADDOSS_ID_REQ_OSG_STATUS);
        } else if (strcasecmp(argv[2], "os") == 0) {
            BuildStatusRequest(&message.mt, imei, ADDOSS_ID_REQ_OBP_STATUS);
        }
        server = argv[3];
    } else if (argc == 6) {
        if (strcasecmp(argv[2], "rd") == 0) {
            start  = strtol(argv[3], NULL, 16);
            end    = strtol(argv[4], NULL, 16);
            server =      argv[5] ;
            BuildArchiveRequest(&message.mt, imei, start, end);
        } else {
            help(argv[0]);
        }
    } else {
        help(argv[0]);
    }

    if (server == NULL) help(argv[0]);

    if ((sbd = sbdOpen(server, port, NULL, NULL, 0)) == NULL) {
        fprintf(stderr, "sbdOpen: ");
        perror(server);
        exit(1);
    }

    if ((retval = sbdPackMessage(&message)) < 0) {
        printf("sbdPackMessage: error %d\n", retval);
        exit(1);
    }

    if (sbdParseMessageBody(&message) != 0) printf("unsupported IEs ignored\n");
    printf("Outgoing message:\n");
    sbdPrintMessageIE(stdout, &message);

    if (!sbdSendMessage(sbd, &message)) {
        perror("sbdSendMessage");
        exit(1);
    }

    printf("%d byte message sent\n", message.len);
    utilPrintHexDump(stdout, message.body, message.len);

    if (message.mt.header.valid) {
        printf("Waiting for confirmation from %s\n", server);
        if (sbdRecvMessage(sbd, &message)) {
            printf("Reply received\n");
            if (sbdParseMessageBody(&message) != 0) printf("unsupported IEs ignored\n");
            sbdPrintMessageIE(stdout, &message);
        } else {
            printf("sbdRecvMessage: %s\n", strerror(errno));
        }
    }

    exit(1);
}
